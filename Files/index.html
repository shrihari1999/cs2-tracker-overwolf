<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="css/style.css" />
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>CS2 Tracker</title>
    <link href="https://fonts.googleapis.com/css?family=Titillium+Web:300,400,600" rel="stylesheet">

    <script src="js/micromodal.min.js"></script>
    <script>
      // Window functions
      function dragMove(){
        overwolf.windows.getCurrentWindow(function(result){
          if (result.status=="success" && result.window.state !== "Maximized"){
            overwolf.windows.dragMove(result.window.id);
          }
        });
      };

      function closeWindow(){
        overwolf.windows.getCurrentWindow(function(result){
          if (result.status=="success"){
            overwolf.windows.close(result.window.id);
          }
        });
      };

      function minimize(){
        overwolf.windows.getCurrentWindow(function(result){
          if (result.status=="success"){
            overwolf.windows.minimize(result.window.id);
          }
        });
      };

      function toggleMaximize(){
        let element = document.querySelector('.maximize-restore-selector'),
            root = document.documentElement;

        overwolf.windows.getCurrentWindow(function(result){
          if (result.status !== "success") {
            return;
          }

          if (element.checked) {
            overwolf.windows.restore(result.window.id);
            root.classList.remove('maximized');
          } else {
            overwolf.windows.maximize(result.window.id);
            root.classList.add('maximized');
          }
        });
      };

      function showSupport() {
        window.location.href = "overwolf://settings/support";
      };

      function dragResize(edge){
        overwolf.windows.getCurrentWindow(function(result){
          if (result.status=="success"){
            overwolf.windows.dragResize(result.window.id, edge);
          }
        });
      };

      function openSubWindow(){
        overwolf.windows.obtainDeclaredWindow("SubWindow", function(result){
          if (result.status == "success"){
            overwolf.windows.restore(result.window.id, function(result){
                
            });
          }
        });
      };
      
      // App classes
      class CS2TrackerDB {
        constructor(dbName = 'CS2TrackerDB', version = 2) {
          this.dbName = dbName;
          this.version = version;
          this.db = null;
        }

        async init() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
              this.db = request.result;
              resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
              const db = event.target.result;

              // Store 1: Raw matches (source of truth)
              if (!db.objectStoreNames.contains('matches')) {
                const matchStore = db.createObjectStore('matches', { keyPath: 'matchId' });
                matchStore.createIndex('timestamp', 'timestamp', { unique: false });
              }

              // Store 2: Denormalized player-match relationships
              if (!db.objectStoreNames.contains('playerMatches')) {
                const pmStore = db.createObjectStore('playerMatches', { keyPath: 'id' });
                pmStore.createIndex('playerId', 'playerId', { unique: false });
                pmStore.createIndex('playerTimestamp', ['playerId', 'timestamp'], { unique: false });
                pmStore.createIndex('matchId', 'matchId', { unique: false });
              }

              // Store 3: Live lobby players
              if (!db.objectStoreNames.contains('lobby')) {
                const lobbyStore = db.createObjectStore('lobby', { keyPath: 'playerId' });
                lobbyStore.createIndex('team', 'team', { unique: false });
              }

              // Store 4: Settings
              if (!db.objectStoreNames.contains('settings')) {
                db.createObjectStore('settings', { keyPath: 'key' });
              }
            };
          });
        }

        // Get existing match ids
        async getExistingMatches() {
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction('matches', 'readonly');
            const store = tx.objectStore('matches');
            const request = store.getAllKeys();

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        }

        // Add a match and create denormalized records
        async addMatch(matchData) {
          console.log('addMatch called with:', matchData.matchId);
          const { matchId, timestamp, team1, team2 } = matchData;

          // Determine result
          let team1Result, team2Result;
          if (team1.score > team2.score) {
            team1Result = 'win';
            team2Result = 'loss';
          } else if (team1.score < team2.score) {
            team1Result = 'loss';
            team2Result = 'win';
          } else {
            team1Result = team2Result = 'tie';
          }
          console.log('Result determined:', team1Result, team2Result);

          const tx = this.db.transaction(['matches', 'playerMatches'], 'readwrite');
          console.log('Transaction created');

          // Store raw match
          const matchRequest = tx.objectStore('matches').add(matchData);
          matchRequest.onsuccess = () => console.log('Match add request succeeded');
          matchRequest.onerror = (e) => console.error('Match add request failed:', e.target.error);

          const pmStore = tx.objectStore('playerMatches');

          // Create denormalized records for team1 players
          console.log('Adding team1 players:', team1.playerIds);
          for (const playerId of team1.playerIds) {
            pmStore.add({
              id: `${playerId}_${matchId}`,
              playerId,
              matchId,
              timestamp,
              result: team1Result,
              teammates: team1.playerIds.filter(id => id !== playerId),
              opponents: team2.playerIds
            });
          }

          // Create denormalized records for team2 players
          console.log('Adding team2 players:', team2.playerIds);
          for (const playerId of team2.playerIds) {
            pmStore.add({
              id: `${playerId}_${matchId}`,
              playerId,
              matchId,
              timestamp,
              result: team2Result,
              teammates: team2.playerIds.filter(id => id !== playerId),
              opponents: team1.playerIds
            });
          }

          return new Promise((resolve, reject) => {
            tx.oncomplete = () => {
              console.log('Transaction completed successfully for:', matchId);
              resolve();
            };
            tx.onerror = () => {
              console.error('Transaction error for:', matchId, tx.error);
              reject(tx.error);
            };
            tx.onabort = () => {
              console.error('Transaction aborted for:', matchId, tx.error);
              reject(tx.error);
            };
          });
        }

        // Get all matches for a specific player
        async getPlayerMatches(playerId) {
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction('playerMatches', 'readonly');
            const store = tx.objectStore('playerMatches');
            const index = store.index('playerId');
            const request = index.getAll(playerId);

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        }

        // Calculate head-to-head records for lobby
        async calculateHistoryRecords(ourUserId, playerId) {
          // Initialize results
          const results = {
            winsAgainst: 0,
            lossesAgainst: 0,
            tiesAgainst: 0,
            againstMatches: [],
            winsWith: 0,
            lossesWith: 0,
            tiesWith: 0,
            withMatches: [],
          }
          
          if (playerId === ourUserId) return results; // Skip self
          
          // Get all our user's matches
          const ourMatches = await this.getPlayerMatches(ourUserId);

          // Process each match
          for (const match of ourMatches) {
            const wasTeammate = match.teammates.includes(playerId);
            const wasOpponent = match.opponents.includes(playerId);

            if (wasTeammate) {
              // Same team - count as "with"              
              if (match.result === 'win') results.winsWith++;
              else if (match.result === 'loss') results.lossesWith++;
              else results.tiesWith++;
              results.withMatches.push({matchId: match.matchId, result: match.result})
            } 
            else if (wasOpponent) {
              // Opposing team - count as "against"              
              if (match.result === 'win') results.winsAgainst++;
              else if (match.result === 'loss') results.lossesAgainst++;
              else results.tiesAgainst++;
              results.againstMatches.push({matchId: match.matchId, result: match.result})
            }
          }

          return results;
        }

        // Get a lobby player by ID
        async getLobbyPlayer(playerId) {
          const tx = this.db.transaction('lobby', 'readonly');
          const store = tx.objectStore('lobby');
          return new Promise((resolve, reject) => {
            const request = store.get(playerId);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        }
      
        // Get players by team (CT or T) - sorted by damage
        async getLobbyPlayersByTeam(team) {
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction('lobby', 'readonly');
            const store = tx.objectStore('lobby');
            const index = store.index('team');
            const request = index.getAll(team);

            request.onsuccess = () => {
              // Sort by damage in descending order (highest first)
              const players = request.result.sort((a, b) => b.damage - a.damage);
              resolve(players);
            };
            request.onerror = () => reject(request.error);
          });
        }

        // Clear all lobby players (for new match)
        async clearLobby() {
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction('lobby', 'readwrite');
            const store = tx.objectStore('lobby');
            const request = store.clear();

            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        }

        // Add a lobby player
        async addLobbyPlayer(player){
          const tx = this.db.transaction('lobby', 'readwrite');
          const store = tx.objectStore('lobby');
          store.put(player);
          return new Promise((resolve, reject) => {
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        }

        // Clear all matches and player matches (for source change re-sync)
        async clearAllMatches() {
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction(['matches', 'playerMatches'], 'readwrite');
            tx.objectStore('matches').clear();
            tx.objectStore('playerMatches').clear();
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        }

        // Get data source setting
        async getDataSource() {
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction('settings', 'readonly');
            const store = tx.objectStore('settings');
            const request = store.get('dataSource');
            request.onsuccess = () => resolve(request.result?.value || 'tracker');
            request.onerror = () => reject(request.error);
          });
        }

        // Set data source setting
        async setDataSource(source) {
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction('settings', 'readwrite');
            const store = tx.objectStore('settings');
            store.put({ key: 'dataSource', value: source });
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        }
      }

      // App variables
      var steamUserId;
      var cs2TrackerDB = new CS2TrackerDB();

      // App functions
      function getTrackerHeaders(){
        return {
          "accept": "application/json, text/plain, */*",
          "accept-language": "en-GB,en-US;q=0.9,en;q=0.8",
          "authorization": "Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkU4NTE1OEM3NDhGNzU1MzgxOUQwQUU5MDVGM0Q1OTkxMjI4MTg3QzIiLCJ0eXAiOiJhdCtqd3QiLCJ4NXQiOiI2RkZZeDBqM1ZUZ1owSzZRWHoxWmtTS0JoOEkifQ.eyJuYmYiOjE3NjMzODE2MDksImV4cCI6MTc2MzM4NTIwOSwiaXNzIjoiaHR0cHM6Ly9hY2NvdW50LnRyYWNrZXIuZ2ciLCJhdWQiOlsiYWNjb3VudCIsImFwaSIsImV2ZW50cyJdLCJjbGllbnRfaWQiOiIwYWYyNTIxZS0zM2U5LTRkNDAtODM2ZS02Zjg2NWNiOTg4NzAiLCJzdWIiOiIxNTUyMDAxMiIsImF1dGhfdGltZSI6MTc2MzI5MjAxMCwiaWRwIjoibG9jYWwiLCJyb2xlIjoiVXNlciIsIm5hbWUiOiIzZGYxMWNhZC02MmFlLTRjMGQtYTQxMC02NDA1NmM4OTdhN2IiLCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIiwiYWNjb3VudCIsImFwaSIsImV2ZW50cyIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AJ-VX_EsFvoJFNlw6bsF1jafunngKC_kQ2H06UJOcj7hxg0ZGwXr7Mtdd6st0Lr7shoJSOqLbQstRfVevEfq9JYVa-1b1tFhvQBKwcKgK9s7GAXrGGmS5z-N54d1dizm6NCtTVLTIdMbuxXpa0Zv4oShqVoEPVjwvTm8pqqx-8AFLtmcqgTubV4W9fL4PERk2Wz7EAZByYZDTwFHl3xM-HUxhsgHXXzBeJIPQ8ghpjGjeg4nYS1n4bTCs-AUGCYN_HM4H3Go8osAZuFL0HZ4LIUrDqLmFdBYBYZC3S-EGJJc6_6l5TBRDlSN9LZ9bLZhs8OWtMdXDZ49pV9v6aaXtdn20NN7fAn4M_CnauYD8n6k4NXxUg2NqzLM2zmar0RUxW1JoiCL_hEPKuBASlAijkoA_xPtH0sqFud7WlOi6Femn1cWm7QcwE4udY8E42CA4eqRIkwIhb7iOk6Yk_10D5FY9lPr9s7E-sPIot5Tw82LrYPFXaGCLi57Y3WkMazZeWt3EnpAp4CTfnHAaG8P2yu6flRbpYmfRUhPXrKAfa21hYSZY9l5o0zfwEMl1wCKc47trOV4ZFZM8mxJHalNvlfWgJSa68Wi-yCRJ4muTmRfR-WD1MpQ7qCMLpDZ_6CbOcBKiOb5rqu-osH8En1YSlaUFgW0rO5-Py3RGTVr2Rg",
          "priority": "u=1, i",
          "sec-ch-ua": "\"Chromium\";v=\"142\", \"Google Chrome\";v=\"142\", \"Not_A Brand\";v=\"99\"",
          "sec-ch-ua-mobile": "?0",
          "sec-ch-ua-platform": "\"Windows\"",
          "sec-fetch-dest": "empty",
          "sec-fetch-mode": "cors",
          "sec-fetch-site": "same-site"
        }
      }

      async function getPlayHours(playerId) {
        const url =
          "https://api.steampowered.com/IPlayerService/GetOwnedGames/v1/?" +
          new URLSearchParams({
            key: '440D7F4D810EF9298D25EDDF37C1F902',
            steamid: playerId,
            "appids_filter[0]": "730"
          });

        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Steam API error: ${res.status}`);
        }

        const data = await res.json();

        const game = data?.response?.games?.[0];
        if (!game || typeof game.playtime_forever !== "number") {
          // profile private or CS2 not owned
          return 0;
        }

        // Steam returns minutes → convert to hours
        return Math.round(game.playtime_forever / 60);
      }

      function getTimeToDamageClass(ttd) {
          if(ttd === '-') return ''
          if(ttd > 575) return 'stat-positive';
          if(ttd > 500) return 'stat-neutral';
          return 'stat-negative';
      }

      function getPreAimClass(preaim) {
          if(preaim === '-') return ''
          if(preaim > 7) return 'stat-positive';
          if(preaim > 5) return 'stat-neutral';
          return 'stat-negative';
      }

      async function getLeetifyStats(playerId) {
        const url =
          "https://api-public.cs-prod.leetify.com/v3/profile?" +
          new URLSearchParams({
            steam64_id: playerId,
          });

        const res = await fetch(url);
        if (!res.ok) {
          return {reaction_time_ms: '-', preaim: '-'}
        }

        const data = await res.json();

        if(!data.stats){
          return {reaction_time_ms: '-', preaim: '-'}
        }
        
        let stats = {
          reaction_time_ms: Math.round(data.stats.reaction_time_ms),
          preaim: Math.round(data.stats.preaim)
        }
        
        return stats
      }

      function openCSWatch(playerId){
        if(playerId != steamUserId){
          window.open(`https://cswatch.in/player/${playerId}`)
        }
      }

      async function openMatchroomsModal(withOrAgainst, el){
        const playerName = decodeURIComponent(el.dataset.name)
        const matches = JSON.parse(el.dataset.matches)
        if(!matches.length){
          return
        }

        const dataSource = await cs2TrackerDB.getDataSource();
        const getMatchUrl = (matchId) => {
          if (dataSource === 'csstats') {
            return `https://csstats.gg/match/${matchId}`;
          }
          return `https://tracker.gg/cs2/matches/${matchId}`;
        };

        let matchroomsModalTitle = document.getElementById('matchrooms-modal-title')
        let matchroomsModalContent = document.getElementById('matchrooms-modal-content')
        matchroomsModalTitle.textContent = `Matchrooms ${withOrAgainst} ${playerName}`
        matchroomsModalContent.innerHTML = matches.map(match => `<a class="matchroom-result matchroom-result-${match.result}" href="${getMatchUrl(match.matchId)}">${match.result[0].toUpperCase()}</a>`).join('')
        MicroModal.show('matchrooms-modal')
      };

      async function setRequiredFeatures() {
        let tries = 1;
        let result;
        const MAX_RETRIES = 100
        const FEATURES_ARRAY = ['match_info']

        while ( tries <= MAX_RETRIES ) {
          result = await new Promise(resolve => {
            overwolf.games.events.setRequiredFeatures(FEATURES_ARRAY, resolve);
          })

          if ( result.success === true ) {
            // make sure our required features were registered
            return (result.supportedFeatures.length > 0);
          }

          // wait 3 sec before retry
          await new Promise(resolve => {
            setTimeout(resolve, 3000);
          });
          tries++;
        }

        console.warn('setRequiredFeatures(): failure after '+ tries +' tries'+ JSON.stringify(result, null, 2));
        return false;
      }

      function getWinRateClass(wins, losses, winRate) {
          if (wins === 0 && losses === 0) return 'neutral';
          if (winRate >= 50) return 'high';
          if (winRate <= 49) return 'low';
          return 'neutral';
      }

      function getRecordClass(wins, losses) {
          if (wins > losses) return 'stat-positive';
          if (losses > wins) return 'stat-negative';
          if (wins === 0 && losses === 0) return '';
          return 'stat-neutral';
      }

      function createPlayerRow(player) {
          const { winsAgainst, lossesAgainst, againstMatches, winsWith, lossesWith, withMatches } = player.records;
          const againstJson = JSON.stringify(againstMatches)
          const withJson = JSON.stringify(withMatches)
          const encodedPlayerName = encodeURIComponent(player.name)
          
          // Calculate win rates
          const againstTotal = winsAgainst + lossesAgainst;
          const withTotal = winsWith + lossesWith;
          const againstWinRate = againstTotal > 0 ? ((winsAgainst / againstTotal) * 100).toFixed(0) : 0;
          const withWinRate = withTotal > 0 ? ((winsWith / withTotal) * 100).toFixed(0) : 0;

          // Determine classes
          const againstClass = getRecordClass(winsAgainst, lossesAgainst);
          const withClass = getRecordClass(winsWith, lossesWith);
          const againstWrClass = getWinRateClass(winsAgainst, lossesAgainst, againstWinRate);
          const withWrClass = getWinRateClass(winsWith, lossesWith, withWinRate);
          
          const timeToDamage = player.leetifyStats?.reaction_time_ms
          const timeToDamageClass = getTimeToDamageClass(timeToDamage)
          const preaim = player.leetifyStats?.preaim
          const preaimClass = getPreAimClass(preaim)

          return `
              <tr>
                  <td onclick="openCSWatch('${player.playerId}')"><span class="player-name">${player.name}</span></td>
                  <td class="text-center">
                      <span class="score">${player.hours}</span>
                  </td>
                  <td class="text-center">
                      <span class="${timeToDamageClass}">${timeToDamage}</span>
                  </td>
                  <td class="text-center">
                      <span class="${preaimClass}">${preaim}</span>
                  </td>
                  <td class="text-center" onclick="openMatchroomsModal('against', this);" data-name='${encodedPlayerName}' data-matches='${againstJson}'>
                      <span class="record ${againstClass}">${winsAgainst}W - ${lossesAgainst}L</span>
                  </td>
                  <td class="text-center" onclick="openMatchroomsModal('against', this);" data-name='${encodedPlayerName}' data-matches='${againstJson}'>
                      <span class="winrate ${againstWrClass}">${againstWinRate}%</span>
                  </td>
                  <td class="text-center" onclick="openMatchroomsModal('with', this);" data-name='${encodedPlayerName}' data-matches='${withJson}'>
                      <span class="record ${withClass}">${winsWith}W - ${lossesWith}L</span>
                  </td>
                  <td class="text-center" onclick="openMatchroomsModal('with', this);" data-name='${encodedPlayerName}' data-matches='${withJson}'>
                      <span class="winrate ${withWrClass}">${withWinRate}%</span>
                  </td>
              </tr>
          `;
      }

      async function renderTeam(team){
        const tbody = document.getElementById(`${team}-players`);
        const players = await cs2TrackerDB.getLobbyPlayersByTeam(team);
        if (players.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" class="empty-state">No players in this team</td></tr>';
            return;
        }
        tbody.innerHTML = players.map(player => createPlayerRow(player)).join('');
      }

      async function handleMatchInfoUpdate(event){
        if(event.feature == 'match_info'){
          let matchInfo = event.info?.match_info
          if(matchInfo){
            let matchInfoKey = Object.keys(matchInfo)[0]
            let matchInfoValue = matchInfo[matchInfoKey]
            if(matchInfoKey.startsWith('roster_')){
              let rosterInfo = matchInfoValue
              if(rosterInfo != 'null'){
                rosterInfo = JSON.parse(rosterInfo)
                if(rosterInfo['steamid'] != '0' && rosterInfo['team']){
                  let player = {playerId: rosterInfo['steamid'], team: rosterInfo['team'], name: rosterInfo['nickname'], damage: rosterInfo['damage'] || 0}
                  const existingPlayer = await cs2TrackerDB.getLobbyPlayer(player.playerId);
                  player.records = existingPlayer && existingPlayer.records ? existingPlayer.records : await cs2TrackerDB.calculateHistoryRecords(steamUserId, player.playerId);
                  player.hours = existingPlayer && existingPlayer.hours ? existingPlayer.hours : await getPlayHours(player.playerId);
                  player.leetifyStats = existingPlayer && existingPlayer.leetifyStats ? existingPlayer.leetifyStats : await getLeetifyStats(player.playerId);
                  await cs2TrackerDB.addLobbyPlayer(player)
                  renderTeam(rosterInfo['team'])
                }
              }
            }
            else if(matchInfoKey == 'pseudo_match_id' && Boolean(matchInfoValue) && matchInfoValue != 'null'){
              cs2TrackerDB.clearLobby()
            }
            else if(matchInfoKey == 'game_mode' && Boolean(matchInfoValue) && matchInfoValue != 'null'){
              let status = document.getElementById('status')
              status.textContent = matchInfoValue
            }
          }
        }
      }

      function handleGameInfoUpdate(event){
        let gameInfo = event.gameInfo
        let status = document.getElementById('status')

        if(gameInfo?.isRunning){
          status.textContent = `${gameInfo?.title} is running`;
          setRequiredFeatures().then(function(success){
            if(success){
              overwolf.games.events.onInfoUpdates2.removeListener(handleMatchInfoUpdate)
              overwolf.games.events.onInfoUpdates2.addListener(handleMatchInfoUpdate)
            }
          })
        }
        else{
          status.textContent = 'Waiting for game to launch...'
        }
      }

      // Rate limiting helpers for csstats.gg
      function extractJSObject(scriptText, idx) {
        const start = scriptText.indexOf('{', idx);
        let depth = 0;
        for (let i = start; i < scriptText.length; i++) {
          if (scriptText[i] === '{') depth++;
          else if (scriptText[i] === '}') depth--;
          if (depth === 0) return JSON.parse(scriptText.substring(start, i + 1));
        }
        return null;
      }

      async function fetchWithRetry(url, retries = 3, baseDelay = 5000) {
        for (let attempt = 0; attempt < retries; attempt++) {
          try {
            const response = await fetch(url, { method: "GET", body: null });
            if (response.ok) {
              return await response.text();
            }
            if (response.status === 429 || response.status === 403) {
              const delay = baseDelay * Math.pow(2, attempt);
              console.warn(`Rate limited on ${url}, retrying in ${delay}ms (attempt ${attempt + 1}/${retries})`);
              await new Promise(r => setTimeout(r, delay));
              continue;
            }
            console.error(`Failed to fetch ${url}: ${response.status}`);
            return null;
          } catch (error) {
            console.error(`Network error fetching ${url}:`, error);
            if (attempt < retries - 1) {
              await new Promise(r => setTimeout(r, baseDelay));
            }
          }
        }
        return null;
      }

      async function fetchBatchWithRateLimit(urls, batchSize = 2, delayMs = 3000, onProgress = null) {
        const results = [];
        for (let i = 0; i < urls.length; i += batchSize) {
          const batch = urls.slice(i, i + batchSize);
          const batchResults = await Promise.all(
            batch.map(url => fetchWithRetry(url))
          );
          results.push(...batchResults);
          if (onProgress) {
            onProgress(results.length, urls.length);
          }
          if (i + batchSize < urls.length) {
            const jitter = Math.random() * 1000;
            await new Promise(r => setTimeout(r, delayMs + jitter));
          }
        }
        return results;
      }

      async function fetchUserHistoryFromCsStats(){
        try {
          const html = await fetchWithRetry(`https://csstats.gg/player/${steamUserId}/stats`);
          if (!html) {
            console.error('Failed to fetch player stats from csstats.gg');
            return;
          }

          const doc = new DOMParser().parseFromString(html, 'text/html');
          const scripts = doc.querySelectorAll('script')

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];
            const idx = script.textContent.indexOf('var stats =')
            if(idx !== -1){
              let stats = extractJSObject(script.textContent, idx)
              let matchIds = stats.matches
              const existingMatchIds = new Set(await cs2TrackerDB.getExistingMatches())
              const newMatchIds = matchIds.filter(matchId => !existingMatchIds.has(matchId));

              if (newMatchIds.length === 0) {
                console.log('No new matches to sync');
                updateSyncStatus('');
                return;
              }

              console.log(`Syncing ${newMatchIds.length} matches from csstats.gg (rate limited)...`);

              const batchSize = 3;
              const delayMs = 2000;
              let syncedCount = 0;

              for (let i = 0; i < newMatchIds.length; i += batchSize) {
                const batchMatchIds = newMatchIds.slice(i, i + batchSize);
                const batchUrls = batchMatchIds.map(matchId => `https://csstats.gg/match/${matchId}`);

                // Fetch batch
                updateSyncStatus(`Fetching ${Math.min(i + batchSize, newMatchIds.length)}/${newMatchIds.length} matches...`);
                const batchResults = await Promise.all(batchUrls.map(url => fetchWithRetry(url)));

                // Process and save each match in the batch immediately
                for (let j = 0; j < batchResults.length; j++) {
                  const newMatchHtml = batchResults[j];
                  if (!newMatchHtml) continue;

                  const matchId = batchMatchIds[j];
                  const matchDoc = new DOMParser().parseFromString(newMatchHtml, 'text/html');
                  let dateStr = matchDoc.querySelector('#last-info .info span:nth-child(2)')
                  let playerLinks = matchDoc.getElementsByClassName('player-link')

                  let simplifiedNewMatch = {
                    matchId: matchId,
                    timestamp: dateStr ? new Date(dateStr.textContent.replace(/(\d+)(st|nd|rd|th)/, '$1')).getTime() : Date.now()
                  }

                  for (let t = 0; t < 2; t++) {
                    let playerLinkGroup = Array.from(playerLinks).slice(t*5, (t+1)*5)
                    let playerIds = playerLinkGroup.map(link => link.href.split('player/')[1])
                    let scoreEl = matchDoc.querySelector(`.team-${t}-score`)
                    let score = scoreEl ? Number(scoreEl.innerText) : 0
                    simplifiedNewMatch[`team${t+1}`] = {score: score, playerIds: playerIds}
                  }

                  try {
                    await cs2TrackerDB.addMatch(simplifiedNewMatch);
                    syncedCount++;
                    updateSyncStatus(`Synced ${syncedCount}/${newMatchIds.length} matches...`);
                    updateMatchCount();
                  } catch (err) {
                    console.error('Failed to save match:', matchId, err);
                  }
                }

                // Rate limit delay between batches
                if (i + batchSize < newMatchIds.length) {
                  const jitter = Math.random() * 1000;
                  await new Promise(r => setTimeout(r, delayMs + jitter));
                }
              }
              console.log(`Successfully synced ${syncedCount} matches from csstats.gg`);
              updateSyncStatus('');
            }
          }
        } catch (error) {
          console.error('Error in fetchUserHistoryFromCsStats:', error);
          updateSyncStatus('');
        }
      }

      function fetchUserHistoryFromTracker(){
        // get total seasons
        fetch(`https://api.tracker.gg/api/v2/cs2/standard/profile/steam/${steamUserId}`, {
          "headers": getTrackerHeaders(),
          "referrer": "https://tracker.gg/",
          "body": null,
          "method": "GET",
        })
        .then(r => r.json())
        .then(r => {
          let seasonIds;
          try {
            seasonIds = r['data']['metadata']['premierSeasons'].map(season => season.id);
          } catch (e) {
            console.warn('Failed to get season IDs, using defaults [1, 2, 3]');
            seasonIds = [1, 2, 3];
          }
          let promises = []
          seasonIds.forEach(seasonId => {
            let promise = fetch(`https://api.tracker.gg/api/v2/cs2/standard/profile/steam/${steamUserId}/segments/season?playlist=premier&seasonId=${seasonId}`, {
              "headers": getTrackerHeaders(),
              "referrer": "https://tracker.gg/",
              "body": null,
              "method": "GET",
            })
            .then(r => r.json())
            promises.push(promise)
          });
          Promise.all(promises).then(responses => {
            let totalMatches = 0
            responses.forEach(r => {
              let season = r['data'].find(d => d['type'] === 'season')
              totalMatches += season['stats']['matchesPlayed']['value']
            });
            let numberOfPages = Math.ceil(totalMatches / 20)
            // scan all matches of player
            let promises = []
            for (let page = 0; page <= numberOfPages; page++) {
              let promise = fetch(`https://api.tracker.gg/api/v2/cs2/standard/matches/steam/${steamUserId}?type=premier&season=&mode=all&next=${page}`, {
                "headers": getTrackerHeaders(),
                "referrer": "https://tracker.gg/",
                "body": null,
                "method": "GET",
              })
              .then(r => r.json())
              promises.push(promise);
            }
            // accumulate counter once all promises resolved
            Promise.all(promises).then(async (matchesResponses) => {
              let matchIds = []
              matchesResponses.forEach(matchesResponse => {
                matchIds.push(...matchesResponse['data']['matches'].map(match => match['attributes']['id']))
              });

              const existingMatchIds = new Set(await cs2TrackerDB.getExistingMatches())
              const newMatchIds = matchIds.filter(matchId => !existingMatchIds.has(matchId));

              if (newMatchIds.length === 0) {
                updateSyncStatus('');
                return;
              }

              updateSyncStatus(`Syncing 0/${newMatchIds.length} matches...`);
              let promises = []
              newMatchIds.forEach(matchId => {
                let promise = fetch(`https://api.tracker.gg/api/v2/cs2/standard/matches/${matchId}`, {
                  "headers": getTrackerHeaders(),
                  "referrer": "https://tracker.gg/",
                  "body": null,
                  "method": "GET",
                })
                .then(r => r.json())
                promises.push(promise);
              });
              Promise.all(promises).then(async (newMatches) => {
                let syncedCount = 0;
                for (const newMatch of newMatches) {
                  let simplifiedNewMatch = {
                    matchId: newMatch['data']['attributes']['id'],
                    timestamp: new Date(newMatch['data']['metadata']['timestamp']).getTime()
                  }
                  let teamIndexMapping = {}
                  newMatch['data']['segments'].filter(segment => segment['type'] == 'team').forEach((segment, index) => {
                    let teamNumber = index + 1
                    simplifiedNewMatch[`team${teamNumber}`] = {score: segment['stats']['score']['value'], playerIds: []}
                    teamIndexMapping[segment['attributes']['teamId']] = teamNumber
                  })
                  newMatch['data']['segments'].filter(segment => segment['type'] == 'player').forEach(segment => {
                    let teamNumber = segment['attributes']['teamId']
                    if(teamIndexMapping[teamNumber]){
                      simplifiedNewMatch[`team${teamIndexMapping[teamNumber]}`].playerIds.push(segment['attributes']['id'])
                    }
                  })

                  await cs2TrackerDB.addMatch(simplifiedNewMatch);
                  syncedCount++;
                  updateSyncStatus(`Syncing ${syncedCount}/${newMatches.length} matches...`);
                  updateMatchCount();
                }
                console.log(`Syncing ${newMatches.length} matches from tracker.gg`);
                updateSyncStatus('');
              })
            })
          })
        })
      }

      function updateSyncStatus(message) {
        const syncStatus = document.getElementById('sync-status');
        if (message) {
          syncStatus.textContent = message;
          syncStatus.style.display = 'block';
        } else {
          syncStatus.style.display = 'none';
        }
      }

      async function updateMatchCount() {
        const matchIds = await cs2TrackerDB.getExistingMatches();
        const matchCount = document.getElementById('match-count');
        matchCount.textContent = `${matchIds.length} matches in database`;
      }

      async function fetchUserHistory(){
        const dataSource = await cs2TrackerDB.getDataSource();

        // Check if data source changed and needs re-sync
        if (localStorage.getItem('dataSourceChanged') === 'true') {
          console.log('Data source changed, clearing all matches for re-sync...');
          await cs2TrackerDB.clearAllMatches();
          localStorage.removeItem('dataSourceChanged');
        }

        if (dataSource === 'csstats') {
          await fetchUserHistoryFromCsStats();
        } else {
          fetchUserHistoryFromTracker();
        }
      }

      async function init(){
        steamUserId = localStorage.getItem('steamUserId')
        if(!steamUserId){
          alert("Please enter your Steam Profile URL or ID to use the app.");
          openSubWindow()
          return
        }
        document.getElementById('open-subwindow').style.display = 'none';
        updateMatchCount();
        fetchUserHistory();

        // Remove all listeners
        overwolf.games.onGameInfoUpdated.removeListener(handleGameInfoUpdate)
        // Initial get
        overwolf.games.getRunningGameInfo2(handleGameInfoUpdate)
        // Add listeners
        overwolf.games.onGameInfoUpdated.addListener(handleGameInfoUpdate);
      }

      window.addEventListener("storage", (event) => {
        if(event.key == 'steamUserId'){
          init()
        }
      });

      document.addEventListener("DOMContentLoaded", async function(){
        // Initialize db
        await cs2TrackerDB.init();
        // Initialize app
        init()
      })

    </script>
  </head>

  <body>
    <div class="content" onmousedown="dragMove();">
      <header>
        <div class="window-controls-group">
          <button class="window-control" onclick="showSupport()">
            <svg class="svg-icon-fill">
              <use xlink:href="assets/svg/sprite.svg#window-control_support" />
            </svg>
          </button>

          <button class="window-control">
            <svg class="svg-icon-fill">
              <use xlink:href="assets/svg/sprite.svg#window-control_settings" />
            </svg>
          </button>

          <button class="window-control" onclick="minimize()">
            <svg class="svg-icon-fill">
              <use xlink:href="assets/svg/sprite.svg#window-control_minimize" />
            </svg>
          </button>

          <button class="window-control" onclick="toggleMaximize()">
            <input type="checkbox" class="maximize-restore-selector toggle-icons" checked />
            <svg class="svg-icon-fill svg-icon-restore">
              <use xlink:href="assets/svg/sprite.svg#window-control_restore" />
            </svg>
            <svg class="svg-icon-fill svg-icon-maximize">
              <use xlink:href="assets/svg/sprite.svg#window-control_maximize" />
            </svg>
          </button>

          <button class="window-control window-control-close" onclick="closeWindow();">
            <svg class="svg-icon-fill">
              <use xlink:href="assets/svg/sprite.svg#window-control_close" />
            </svg>
          </button>
        </div>
      </header>

      <main>
        <div class="modal micromodal-slide" id="matchrooms-modal" aria-hidden="true">
          <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="matchrooms-modal-title">
              <header class="modal__header">
                <h2 class="modal__title" id="matchrooms-modal-title"></h2>
              </header>
              <div class="modal__content" id="matchrooms-modal-content"></div>
              <footer class="modal__footer">
                <button class="btn" data-micromodal-close aria-label="Close this dialog window">Close</button>
              </footer>
            </div>
          </div>
        </div>
        <div class="info-banner">
            <h2>CS2 Tracker</h2>
            <p id="status">Waiting for Steam Profile URL or ID...</p>
            <p id="sync-status" style="display: none; font-size: 12px; color: #888;"></p>
            <p id="match-count" style="font-size: 12px; color: #888;"></p>
            <div class="btn-group">
              <button class="btn" id="open-subwindow" onclick="openSubWindow();">Enter Steam Profile URL or ID</button>
            </div>
        </div>

        <div class="lobby-container">
            <!-- CT Team -->
            <div class="team-section team-ct">
                <div class="team-header">Counter-Terrorists</div>
                <table id="ct-table">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th class="text-center">Hours</th>
                            <th class="text-center">TTD</th>
                            <th class="text-center">Preaim °</th>
                            <th class="text-center">All time vs Them</th>
                            <th class="text-center">Win %</th>
                            <th class="text-center">All time w/ Them</th>
                            <th class="text-center">Win %</th>
                        </tr>
                    </thead>
                    <tbody id="CT-players">
                        <tr>
                            <td colspan="8" class="loading">No players in this team</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- T Team -->
            <div class="team-section team-t">
                <div class="team-header">Terrorists</div>
                <table id="t-table">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th class="text-center">Hours</th>
                            <th class="text-center">TTD</th>
                            <th class="text-center">Preaim °</th>
                            <th class="text-center">All time vs Them</th>
                            <th class="text-center">Win %</th>
                            <th class="text-center">All time w/ Them</th>
                            <th class="text-center">Win %</th>
                        </tr>
                    </thead>
                    <tbody id="T-players">
                        <tr>
                            <td colspan="8" class="loading">No players in this team</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
      </main>
    </div>

    <div class="resize horizontal top" onmousedown="dragResize('Top');"></div>
    <div class="resize vertical left" onmousedown="dragResize('Left');"></div>
    <div class="resize vertical right" onmousedown="dragResize('Right');"></div>
    <div class="resize horizontal bottom" onmousedown="dragResize('Bottom');"></div>

    <div class="resize corner top-left" onmousedown="dragResize('TopLeft');"></div>
    <div class="resize corner top-right" onmousedown="dragResize('TopRight');"></div>
    <div class="resize corner bottom-left" onmousedown="dragResize('BottomLeft');"></div>
    <div class="resize corner bottom-right" onmousedown="dragResize('BottomRight');"></div>
  </body>
</html>
